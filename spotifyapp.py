# -*- coding: utf-8 -*-
"""spotifyapp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mfblxzPUSDusSfc6l1zafZ7HAO9zO-DY
"""

# --------------------------------------
# ðŸŽµ Spotify AI Recommender 
# --------------------------------------

# ðŸ“¦ Imports
import streamlit as st
import pandas as pd
import numpy as np
import json
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score, f1_score, roc_auc_score, roc_curve
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from xgboost import XGBClassifier
import matplotlib.pyplot as plt

# ðŸ›  Streamlit App Config
st.set_page_config(page_title="ðŸŽµ Spotify ML Mood Recommender", layout="wide")

# --------------------------------------
# ðŸ“… Load Data
# --------------------------------------
@st.cache_data(show_spinner=True)
def load_data():
    df = pd.read_csv("spotify_tracks.csv", low_memory=False)
    df = df.drop_duplicates(subset=['track_name', 'track_genre'], keep='first')
    audio_cols = ['danceability', 'energy', 'loudness', 'speechiness', 'acousticness',
                  'instrumentalness', 'liveness', 'tempo', 'duration_ms', 'valence']
    df[audio_cols] = df[audio_cols].fillna(df[audio_cols].mean()).astype(np.float32)
    return df, audio_cols

# ðŸ“Š Load and prepare data
spotify_df, model_features = load_data()

# Prepare data for model training
X_valence = spotify_df[model_features[:-1]]
y_valence = (spotify_df['valence'] > 0.5).astype(int)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_valence)
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_valence, test_size=0.2, random_state=42)

# ðŸ§  Train and evaluate models
st.sidebar.title("ðŸ”§ Model Evaluation")
selected_model_name = "XGBoost"

if st.sidebar.checkbox("Show Model Comparison"):
    models = {
        "Logistic Regression": LogisticRegression(max_iter=1000),
        "Random Forest": RandomForestClassifier(n_estimators=200),
        "SVM": SVC(probability=True),
        "XGBoost": XGBClassifier(use_label_encoder=False, eval_metric='logloss')
    }

    results = []
    fig, ax = plt.subplots(figsize=(8, 6))

    best_auc = 0
    for name, model in models.items():
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        y_prob = model.predict_proba(X_test)[:, 1]

        acc = accuracy_score(y_test, y_pred)
        f1 = f1_score(y_test, y_pred)
        auc = roc_auc_score(y_test, y_prob)
        results.append({"Model": name, "Accuracy": acc, "F1 Score": f1, "ROC AUC": auc})

        if auc > best_auc:
            best_auc = auc
            selected_model_name = name

        fpr, tpr, _ = roc_curve(y_test, y_prob)
        ax.plot(fpr, tpr, label=f"{name} (AUC = {auc:.2f})")

    ax.plot([0, 1], [0, 1], linestyle='--', color='gray')
    ax.set_xlabel("False Positive Rate")
    ax.set_ylabel("True Positive Rate")
    ax.set_title("ROC Curve Comparison")
    ax.legend()
    st.pyplot(fig)

    results_df = pd.DataFrame(results).sort_values("ROC AUC", ascending=False)
    st.subheader("ðŸ“Š Model Performance Summary")
    st.dataframe(results_df.style.format({"Accuracy": "{:.4f}", "F1 Score": "{:.4f}", "ROC AUC": "{:.4f}"}))

# Select and apply best model
model_map = {
    "Logistic Regression": LogisticRegression(max_iter=1000),
    "Random Forest": RandomForestClassifier(n_estimators=200),
    "SVM": SVC(probability=True),
    "XGBoost": XGBClassifier(use_label_encoder=False, eval_metric='logloss')
}

valence_model = model_map[selected_model_name]
valence_model.fit(X_scaled, y_valence)
spotify_df['predicted_valence'] = valence_model.predict(X_scaled)

# --------------------------------------
# ðŸŽµ ML-Based Mood Recommendation Page
# --------------------------------------
st.title("ðŸŽµ ML-Based Mood Song Recommender)")
st.markdown(f"*Using Model:* {selected_model_name} for prediction")

filter_choice = st.radio("Filter by", ["None", "Genre", "Mood"])
filtered_df = spotify_df.copy()

if filter_choice == "Genre":
    genres = sorted(spotify_df['track_genre'].dropna().unique())
    genre_filter = st.selectbox("Select Genre", genres)
    filtered_df = filtered_df[filtered_df['track_genre'].str.lower() == genre_filter.lower()]

elif filter_choice == "Mood":
    mood = st.radio("Select Mood", ["Happy", "Calm"])
    if mood == "Happy":
        filtered_df = filtered_df[filtered_df['predicted_valence'] == 1]
    else:
        filtered_df = filtered_df[filtered_df['predicted_valence'] == 0]

if not filtered_df.empty:
    top_k = st.slider("Select number of songs to recommend", 5, 50, 10)
    recommendations = filtered_df.sample(top_k)
    st.subheader("ðŸŽ§ Recommended Songs")
    st.dataframe(recommendations[['track_name', 'track_genre', 'energy', 'valence']], use_container_width=True)
else:
    st.warning("No songs found for the selected filter.")

